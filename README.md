# WebAssembly Binary Format (My Journey)

As I delve into the world of WebAssembly, I'm struck by its binary format. It's
a sequence of bytes that holds the key to executing WebAssembly code in various
environments. My goal is to understand and document this process, sharing my
journey with you.

## Getting Started

Before we begin writing our WebAssembly programs in the binary format (which
will also be referred to as byte-code), it's essential to set up a suitable
development environment.

We'll need tools to help with three key tasks:

- Writing and executing byte-code.
- Converting byte-code to human-readable text format.
- Visualizing and comparing binary formats.

### Runtime Environment

To begin, I need a convenient way to write and execute WebAssembly code. I've
chosen JavaScript for its simplicity, which allows me to instantiate a module
with just a couple of function calls.

I'm using Deno as my runtime environment:

https://github.com/denoland/deno

### WABT

Occasionally, we need to debug or inspect our WebAssembly programs. The
WebAssembly Binary Toolkit (WABT) provides the necessary tools for this task:

- `wasm-decompile` generates C-like syntax from our byte-code, making it easier
  to understand and debug.
- `wasm-objdump` disassembles our byte-code, allowing us to inspect its sections
  and gain insights into its structure.
- `wasm2wat` translates our byte-code into a human-readable text format, making
  it easier to comprehend and analyze.
- `wat2wasm` provides an essential debugging aid by translating our
  human-readable text format code into byte-code. This allows us to compare the
  generated byte-code with our own, helping us identify any discrepancies and
  make necessary adjustments.

You can find WABT on the official repository:

https://github.com/WebAssembly/wabt

If you're using MSYS2, you can install it from their repository:

https://packages.msys2.org/base/mingw-w64-wabt

### hexdump and xxd

To compare byte-codes, we need a way to visualize the binary data. We can use
either hexdump or xxd, both of which serve this purpose.

Here's an example of how we might use each tool:

```
hexdump -C fact.wasm
00000000  00 61 73 6d 01 00 00 00  01 06 01 60 01 7e 01 7e  |.asm.......`.~.~|
00000010  03 02 01 00 07 08 01 04  66 61 63 74 00 00 0a 29  |........fact...)|
00000020  01 27 01 01 7e 42 01 21  01 02 40 03 40 20 00 42  |.'..~B.!..@.@ .B|
00000030  02 54 0d 01 20 00 20 01  7e 21 01 20 00 42 01 7d  |.T.. . .~!. .B.}|
00000040  21 00 0c 00 0b 0b 20 01  0b                       |!..... ..|
00000049
```

```
xxd fact.wasm
00000000: 0061 736d 0100 0000 0106 0160 017e 017e .asm.......`.~.~
00000010: 0302 0100 0708 0104 6661 6374 0000 0a29 ........fact...)
00000020: 0127 0101 7e42 0121 0102 4003 4020 0042 .'..~B.!..@.@ .B
00000030: 0254 0d01 2000 2001 7e21 0120 0042 017d .T.. . .~!. .B.}
00000040: 2100 0c00 0b0b 2001 0b                  !..... ..
```

Both tools can be installed as follows:

- hexdump is included in the basic MSYS2 installation.
- xxd is available in the vim package: https://packages.msys2.org/base/vim

### WebAssembly Specification

The official specification is an exhaustive resource that I'll be citing and
referring to throughout this guide. You can find it in the official repository:

https://github.com/WebAssembly/spec

## Hello World!

I'm overwhelmed by the sheer volume of the specification. As a starting point,
we can attempt to reverse-engineer the WebAssembly binary format.

Obviously, our WebAssembly byte-code is expected to have some kind of header. I
suspect that JavaScript will provide feedback on the expected format through
error messages.

### Instantiating a Module

My first step is to instantiate a module using an empty source. I'm curious to
see what happens when I try to execute it.

```typescript
const source = Uint8Array.of()
const instantiatedSource = await WebAssembly.instantiate(source)
```

Running the code yields an error: `BufferSource argument is empty`. It's clear
that an empty source isn't enough. Let's try adding something to the mix.

```typescript
const source = Uint8Array.of(0x00)
```

This time, I get an error message indicating that I need 4 bytes to proceed:
`expected 4 bytes, fell off end @+0`.

```typescript
const source = Uint8Array.of(0x00, 0x00, 0x00, 0x00)
```

However, I'm still missing the mark. The error message suggests that I need to
include a magic word: `expected magic word 00 61 73 6d, found 00 00 00 00 @+0`.

```typescript
const source = Uint8Array.of(0x00, 0x61, 0x73, 0x6d)
```

But I'm not there yet. The error message now indicates that I need to add more
bytes: `expected 4 bytes, fell off end @+4`.

```typescript
const source = Uint8Array.of(0x00, 0x61, 0x73, 0x6d, 0x00, 0x00, 0x00, 0x00)
```

The error message reveals that the second 4 bytes are actually a version number.
Since there is only one current WebAssembly format version, it should be set to
1: `expected version 01 00 00 00, found 00 00 00 00 @+4`.

```typescript
const source = Uint8Array.of(0x00, 0x61, 0x73, 0x6d, 0x01, 0x00, 0x00, 0x00)
```

This sequence is a valid WebAssembly binary that compiles and executes without
errors. I've come a long way, but I'm not done yet.

## It's... useless?

We've successfully written a bare-minimum program in WebAssembly binary format,
but it's still useless. To make it do something, we need to add more structure
and meaning to our code. Reverse-engineering alone won't get us there, so let's
dive into the WebAssembly specification to uncover its secrets and gain a deeper
understanding of how it works.

### Types

One of the first things I want to understand is types. The specification defines
several type categories, including:

Number Types (numtype):

- 0x7C represents f64.
- 0x7D represents f32.
- 0x7E represents i64.
- 0x7F represents i32.

Reference Types (reftype):

- 0x6F denotes externref.
- 0x70 denotes funcref.

Vector Types (vectype):

- 0x7B indicates v128.

Value Types (valtype):

- Comprises numtype, reftype, and vectype.

These types define the fundamental data types in WebAssembly, including
floating-point numbers and integers.

Next, we need to understand function types. In WebAssembly, functions are
defined as:

> Function types are encoded by the byte 0x60 followed by the respective vectors
> of parameter and result types.

> Result types are encoded by the respective vectors of value types.

A function type is a sequence of bytes that defines the input and output types
of a function. Let's break it down:

- The first byte (`0x60`) indicates that this is a function type.
- The next two sequences define the result types of the function, which are
  vectors of value types.

But what's a vector? It has the following definition:

> Vectors are encoded with their u32 length followed by the encoding of their
> element sequence.

Don't be confused by this vector and the `vectype` definition earlier. While
both are related to vectors, they serve different purposes.

Let's look at an example of what a function type might look like in binary
format:

```
60
02 7f 7f ; 2 parameters, both of type i32 (7f)
01 7f    ; 1 return type of type i32 (7f)
```

By understanding these fundamental concepts, we're one step closer to creating
meaningful and useful WebAssembly code.

### To Be Continued
